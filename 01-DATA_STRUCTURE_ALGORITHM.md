# 1227 스터디

- 시간복잡도와 공간복잡도에 대해 설명해 주세요.
    
    시간복잡도는 어떤 알고리즘을 수행하는 데 걸리는 시간을 설명하는 계산 복잡도
    
    시간복잡도는 알고리즘이 입력 크기(N)에 따라 실행하는 연산 수를 측정한 값으로, 알고리즘의 수행 시간이 입력 크기에 따라 어떻게 변화하는지를 나타냅니다. 공간복잡도는 알고리즘이 실행될 때 사용하는 메모리 양을 나타내며, 입력 크기에 따라 메모리 사용량이 어떻게 변화하는지 측정합니다.
    
    - Big-O, Big-Theta, Big-Omega 에 대해 설명해 주세요.
        
        세 가지 경우 모두 점근적 표현방식으로 빅-오는 알고리즘의 수행 시간 상한을, 빅-오메가는 수행 시간 하한을, 빅-세타는 알고리즘의 상한과 하한이 모두 동일한 경우를 나타냅니다. 즉, 빅-세타는 해당 알고리즘의 **상한과 하한이 동일하게 표기될 때**, 충분히 큰 입력 크기 n에 대해 시간복잡도가 동일하게 증가한다고 말할 수 있습니다.
        
    - 다른 것을 사용하지 않고, Big-O를 사용하는 이유가 있을까요?
        
        Big-O는 알고리즘의 최악의 경우를 기준으로 복잡도를 표현하므로, 실제 환경에서의 최악의 시나리오를 대비하는 데 유용합니다. 또한 시간복잡도를 근사화하여 많은 알고리즘을 쉽게 비교하고 이해하기 쉽도록 합니다. 업계에서는 알고리즘을 판단할 때 보다 안정적이고 보수적인 판단 기준으로 최악의 경우를 잡기 때문에 빅-오만을 사용합니다.
        
    - O(1)은 O(N^2) 보다 무조건적으로 빠른가요?
        
        아니오. O(N^2)의 상수가 매우 작거나 O(1)의 상수가 매우 크다면, 특정한 경우 O(N^2)가 O(1)보다 빠를 수도 있습니다. 빅-오 표기법은 충분히 큰 N에 대해서 점근적인 경향성을 나타낼 뿐, 모든 경우의 절대적인 속도를 나타내지 않습니다. - O(1)이 입력크기와 상관없이 일정한 시간을 가지는 지도 언급을 하는 게 나은지..
        
- 링크드 리스트에 대해 설명해주세요.
    
    링크드 리스트는 데이터를 저장하는 노드들의 연결된 집합입니다. 각 노드는 데이터 값과 다음 노드의 주소-포인터-를 포함하며, 이를 통해 다음 노드와 연결됩니다. 연속된 메모리 공간을 요구하지 않아 확장과 축소가 비교적 쉽게 이루어집니다.
    
    - 일반 배열과, 링크드 리스트를 비교해 주세요.
        
        배열은 연속된 메모리 공간에 데이터를 저장하며, 많은 경우에 배열 안의 모든 요소가 동일한 데이터 타입을 가지도록 요구됩니다. 인덱스로 접근할 시 O(1)의 시간복잡도가 걸리지만, 삽입/삭제가 이루어지는 경우에는 모든 데이터를 훑어야 하기 때문에 O(N)의 시간이 걸립니다.
        하지만 링크드 리스트는 각 노드가 독립적으로 저장되며, 노드가 다음 노드를 가르키는 주소를 포함하고 있습니다. 삽입과 삭제가 O(1)의 시간복잡도를 가지지만, 배열과 반대로 특정 노드를 접근할 때 순차적으로 탐색해야 하기 때문에 O(N)의 시간복잡도를 가집니다.
        
    - 링크드 리스트를 사용해서 구현할 수 있는 다른 자료구조에 대해 설명해주세요.
        
        스택/큐를 링크드 리스트로 만들게 되면, 삽입과 삭제를 O(1) 시간 복잡도로 처리할 수 있습니다.
        노드에 앞선 노드의 주소를 포함하게 하는 이중 연결 리스트를 만들 수도 있습니다. - 원형 연결 리스트도 가능
        그래프의 인접 노드를 표현할 때 링크드 리스트로 구현할 수 있습니다.
        트리의 부모-자식간의 노드 연결을 링크드 리스트로 구현할 수 있습니다.
        
- 스택과 큐에 대헤서 설명해주세요.
    
    스택은 Last In First Out, 마지막에 들어간 것이 가장 먼저 나오는 - 먼저 들어간 것이 뒤에 나오는 선입후출의 구조를 가지고 있습니다. 데이터를 삽입하는 Push, 제거하는 Pop, 가장 위의 것을 보는 Peek 연산을 수행할 수 있습니다. 반면 큐는 First In First Out, 먼저 들어간 것이 먼저 나오는 선입선출 구조를 가지고 있습니다.
    
    - 스택 2개로 큐를, 큐 2개로 스택을 만드는 방법과 그 시간복잡도에 대해 설명해주세요.
        
        큐는 스택 하나를 입력 스택으로 사용하고, 다른 스택 하나를 출력 스택으로 사용하면 만들 수 있습니다. 큐에 넣는 Enqueue 연산은 데이터를 입력 스택에 데이터를 푸시하고, 큐에서 제거하는 Dequeue 연산은 출력 스택을 확인한 후 비어 있으면, 입력 스택의 모든 데이터를 출력 스택에 푸시한 후 데이터를 팝하여 구현할 수 있습니다.
        
        스택은 메인 큐와 서브 큐로 구현할 수 있습니다. 스택에 데이터를 넣는 push는 데이터를 서브 큐에 추가하고, 메인 큐의 모든 데이터를 서브 큐로 옮긴 뒤, 서브 큐를 메인 큐로 교체하면 됩니다. pop은 메인 큐에서 데이터를 제거하면 됩니다.
        
    - 시간복잡도를 유지하면서, 배열로 스택과 큐를 구현할 수 있을까요?
        
        빼먹었다..
        
    - Prefix, Infix, Postfix에 대해 설명하고, 이를 스택을 활용해서 계산하는 방법에 대해 설명해주세요.
        
        Infix: 우리가 일반적으로 사용하는 수식 형태로, 피연산자 사이에 연산자가 위치합니다. 3+4
        
        스택 두 개로 연산. 연산자 스택, 피연산자 스택. 왼쪽에서 오른쪽으로 읽어가면서 계산을 진행합니다.
        
        Prefix: 피연산자 앞에 연산자가 위치합니다. +34
        
        오른쪽에서 왼쪽으로 읽어가면서 계산. 피연산자는 스택에 푸시하고, 연산자를 만나면 pop을 두번 한 뒤 연산자로 계산, 그 후 결과를 다시 스택에 푸시하면 됩니다.
        
        Postfix: 피연산자 뒤에 연산자가 위치합니다. 34+
        
        왼쪽부터 순차적으로 읽어가면서 계산.
        
    - Deque는 어떻게 구현할 수 있을까요?
        
        Deque, 덱은 Double-ended queue으로써 양 끝에서 모두 데이터를 삽입하고 삭제할 수 있는 자료구조입니다. 배열과 연결리스트를 사용해서 구현할 수 있습니다.
        
- 해시 자료구조에 대해 설명해 주세요.
    
    해시테이블은 데이터를 키-값 쌍으로 구성하여 효율적으로 저장하고 검색하기 위한 자료구조입니다. 해시 함수-임의 크기 데이터를 고정 크기 값으로 매핑하는 데 사용할 수 있는 함수-글리치 를 사용해 키를 해시값으로 변환하여 매핑합니다.
    해시 테이블은 키를 값에 매핑할 수 있는 구조인, 연관 배열 추상 자료형을 구현하는 자료구조입니다.
    
    - 값이 주어졌을 때, 어떻게 하면 충돌이 최대한 적은 해시 함수를 설계할 수 있을까요?
        
        첫째로 주어진 데이터의 크기와 유형을 분석해야 합니다.
        
        -> 가능한 한 키를 고르게 분포시킵니다. 소수를 이용한 모듈러 연산을 사용할 수 있습니다.
        
        둘째로 충분히 큰 테이블 크기를 가짐으로써 충돌 확률을 줄일 수 있습니다.
        
    - 해시값이 충돌했을 떄, 어떤 방식으로 처리할 수 있을까요?
        
        개별 체이닝(Separate Chaining)과 오픈 어드레싱이 있습니다. 개별 체이닝은 연결 리스트를 사용하는 방식으로, 해시 값을 이용해 인덱스를 구하고 같은 인덱스가 있다면 연결 리스트로 연결하는 방식입니다. 이는 구현이 간단하고, 가장 전통적인 방법입니다. 최악의 경우 O(N)의 시간복잡도를 가집니다.
        
        오픈 어드레싱은 충돌 발생 시 빈 공간을 찾아나서는 방식입니다. 탐사-Probing-를 통해 이루어지기 때문에 모든 원소가 반드시 자신의 해시값과 일치하는 주소에 저장된다는 보장은 없습니다. 가장 간단한 방법으로는 충돌이 난 위치부터 순차적으로 찾아보는 선형 탐사가 있습니다. 오픈 어드레싱은 데이터가 고르게 분포되지 않고 한 곳에 뭉치는 클러스터링 현상이 일어나는 문제점이 있습니다. 이는 데이터가 많아질수록 성능이 저하됩니다.
        
    - 본인이 사용하는 언어에서는 어떤 방식으로 해시 충돌을 처리하나요?
        
        파이썬에서는 해시 테이블을 이용한 자료형으로 딕셔너리가 있고, 충돌 시 오픈 어드레싱 방식을 사용합니다.
        
    - Double Hashing의 장점과 단점에 대해 설명하고, 단점을 어떻게 해결할 수 있을지 설명해 주세요.
        
        더블 해싱 - 이중 해싱 - 은 서로 다른 해시 함수를 사용하는 방식으로, 충돌을 줄이고, 효율적으로 해시 테이블의 공간을 활용해 클러스터링을 방지할 수 있습니다. 이는 성능이 개선되는 효과를 가지고 있습니다. 반면 단점으로는 서로 다른 해시 함수를 사용해야 하기 때문에 구현이 복잡하고, 잘못 만들면 일정 주기로 계속 충돌이 발생해 클러스터링 현상이 일어날 수 있습니다.
        이를 개선하기 위해서 두 해시 함수를 독립적으로 구성해야 합니다.
        
    - Load Factor에 대해 설명해 주세요. 본인이 사용하는 언어에서의 해시 자료구조는 Load Factor에 관련한 정책이 어떻게 구성되어 있나요?
        
        로드 팩터란 해시 테이블에 저장된 데이터 개수 n을 버킷의 개수 k로 나눈 것입니다. 즉 데이터의 수를 테이블의 크기로 나눈 값이며, 로드 팩터가 높아질 수록 충돌 가능성이 증가하고 성능 저하가 일어날 수 있습니다. 이 비율에 따라서 재해싱 해야할지 결정하는 기준이 되기도 하며, 얼마나 잘 분산됐는지 효율성 측면에서도 사용됩니다. 자바는 0.75, 파이썬은 0.66, 루비는 0.5 를 기준으로 재해싱을 진행합니다.
        
    - 다른 자료구조와 비교하여, 해시 테이블은 멀티스레드 환경에서 심각한 수준의 Race Condition 문제에 빠질 위험이 있습니다. 성능 감소를 최소화 한 채로 해당 문제를 해결할 수 있는 방법을 설계해 보세요.
        
        해시 테이블에 대해 개별적으로 락을 적용하는 Segmented Locking을 적용하고, 읽기 작업과 쓰기 작업을 분리하여 최소화할 수 있습니다.
        
- 트리와 이진트리, 이진탐색트리에 대해 설명해 주세요.
    
    트리는 계층적인 구조를 가진 비선형적 자료구조로 노드와 간선으로 이루어져 있습니다. 루트 노드에서 시작하며 각 노드는 자식 노드를 가지고 있습니다. 간선으로 이어진 노드 간에는 순환(Cycle)이 없어야 하며, 루트에서 에서 어떤 노드로든 단 하나의 경로만 가지고 있어야 합니다.
    
    이진 트리는 각 노드가 최대 두 개의 자식을 가질 수 있는 트리이고, 이진 탐색 트리는 이진 트리이면서 두 가지 특징을 더 지니고 있습니다. 첫째. 왼쪽 서브 트리에 있는 값은 루트보다 작아야 한다. 둘째, 오른쪽 서브 트리에 있는 값은 루트보다 커야한다. 
    
    - 그래프와 트리의 차이가 무엇인가요?

        트리 : 루트 O / 순환 X / 모든 노드가 연결 / 방향성 존재

        그래프 : 루트 X / 순환 O / 연결되지 않을 수도 있음 / 무방향성 가능
        + 트리는 순환이 없는 방향 그래프 (DAG)

        
    - 이진탐색트리에서 중위 탐색을 하게 되면, 그 결과는 어떤 의미를 가지나요?
        
        왼쪽 서브트리 -> 루트 -> 오른쪽 서브트리 순서로 방문하기 때문에 노드 값들이 오름차순으로 정렬됩니다.
        
    - 이진탐색트리에서 주요 연산에 대한 시간복잡도를 설명하고, 왜 그런 시간복잡도가 도출되는지 설명해 주세요.
        
        검색과 삽입은 동일한 시간복잡도를 가집니다. 완전 이진 트리의 경우 O(log H), 최악의 경우는 O(H)가 됩니다. 삭제의 경우도 O(H) 지만, 노드가 가진 자식 노드에 따라 추가 작업이 필요합니다. 자식이 두 개 있을 경우 오른쪽 서브트리의 최솟값으로 만들거나, 왼쪽 서브트리의 최댓값으로 변경해야 합니다.
        
    - 이진탐색트리의 한계점에 대해 설명해 주세요.
        
        이진트리의 한계점으로는 트리가 편향될 수 있다는 점이 있습니다. -> RB 트리까지 설명해야 할까?
        
    - 이진탐색트리의 값 삽입, 삭제 방법에 대해 설명하고, 어떤 식으로 값을 삽입하면 편향이 발생할까요?
        
        삽입은 루트부터 비교해가며 왼쪽과 오른쪽 서브트리로 이동해서 이중 탐색 트리의 조건에 만족하는 곳에서 삽입하면 됩니다.
        
        삭제는 자식이 없을 경우 바로 삭제, 하나만 있을 경우 삭제 뒤 자식 노드를 부모 노드와 이어주면 됩니다. 자식이 두 개 있을 경우 오른쪽 서브트리의 최솟값으로 만들거나, 왼쪽 서브트리의 최댓값으로 변경해야 합니다.
        
        정렬된 데이터를 삽입하면 편향이 발생합니다.
        
    - 이진탐색트리와 동일한 로직을 사용하면, 삼진탐색트리도 정의할 수 있을까요? 안 된다면, 그 이유를 설명해 주세요.
        
        Ternary Search Tree는 정의 가능합니다. - 문자열 검색, 사전 등에서 사용됨
